\chapter{PIR implementation}
\label{cha:3}


\section{GBFV-PIRANA, single-query small payload}
In this section, the implementation of the PIRANA protocol using the easy-GBFV library is presented. The implementation is a single-query implementation for small payloads. This means that the elements of the database are smaller when compared to the plaintext modulus $p$. To test the implementation, client and server are created in the same file. Therefore, there is no need to send the public key from client to server. The single-query small payload implementation can be found in the \verb|examples\5_GBFV_PIRANA_Spayload| folder of the thesis github \footnote{\textcolor{red}{github implementation of antoine}}. 

First, a database/matrix is created with size $r \cdot c$, where $r$ is equal to the number of slots in the ciphertext and $c$ is equal to the amount of elements divided by the number of slots in the ciphertext \footnote{When working with small payloads, all elements in the database are of maximal size i32 or plaintext modulo.}. All indices of the columns of the matrix are substituted with a constant weight codeword. To achieve this, $m$ and $k$ have to be chosen properly. In this implementation, $k$ will be set to 2, meaning that every codeword has a Hamming weight of 2. This will keep the amount of ciphertext-ciphertext multiplications low. Knowing $k$, $m$ can be calculated as $c \leq \binom{m}{2}$, with $c$ the amount of columns in the matrix. Later, every column will be multiplied with a ciphertext. Therefore, the plaintext elements of one column are set into a plaintext ring.

Subsequently, an instance of GBFV is created. When creating this instance, one has to set several attributes. One has to choose $m1$ in such a way that $m$, the cyclotomic order, can be divided by $m1$, to create the number of slots $m2$. A second attribute is $log2(N)$, which will determine the cyclotomic order $m$ as $m = 2^{log2(N)+1}$. \textcolor{red}{ A prime number $p_{mod}$ is a prime which will determine the plaintext modulus.} Attribute $t$, which is the plaintext modulus, also has to be set. In our case, we use BGFV, so $t$ is a polynomial. 
After creating the GBFV instance, the slot\_ring() function will create a slot representation. 

Having a database and having created a GBFV instance, the PIRANA set-up is finished. The client can now create a query for an element in the database. Imagine the client wants to retrieve element ($i,j$) from the database. First, the client will look up which codeword corresponds to column $j$. The client will create the query matrix, which is a matrix of size $r \cdot m$. This matrix is an all-zero matrix, except for the $i$-th row, which is subsituted with the codeword. 

Before sending the query, the client has to encrypt the query. Therefore, he generates a secret key and a public key. Every column of length $r$ (amount of slots in a ciphertext) will be encrypted. The client sends $m$ ciphertexts to the server. 

The server will, for each column, take the codewords of length $m$ and look at which position the codeword has a 1. In our case, there are only two one's (remember, the Hamming weight equals 2). The server will take the corresponding ciphertexts of these two positions in the query and multiply them with each other. This new ciphertext is one column of the selection matrix. This process is repeated for all $c$ columns of the database. After creating the selection matrix, the server will perform a homomorphic plaintext-ciphertext multiplication between every column of the selection matrix and the corresponding column of the database. Finally, all the columns of the resulting matrix are summed together, by going through all the columns and adding them via an accumulator. The result is then sent back as one ciphertext to the client. 

The client will receive the ciphertext from the server and will decrypt using his secret key. Every ciphertext is decrypted and will return a vector of slot ring elements. All elements are equal to zero, except for the $i$-th element, which is equal to the desired element in the database. The client can now format this element and retrieve the desired value. 



\section{GBFV-PIRANA, single-query large payload}
In this section, the implementation of a single-query PIR protocol for large payloads using the easy-GBFV library is presented. The implementation can be found in the \verb|examples\5_GBFV_PIR_Lpayload| folder of the thesis github \footnote{\textcolor{red}{github implementation of antoine}}.

% To create the database, some specific help functions are used\footnote{All of the helper functions are in \verb|examples\\6_GBFV_PIR_Lpayload\\matrix_util|}:


\begin{itemize}
    \item d3\_finder(element\_size\_bit: usize, p\_mod: \&str): This function will determine in how many chunks a large payload can be split. It will return the amount of chunks. To achieve this, the function needs to know the \textcolor{red}{plaintext modulus p\_mod} and the maximal size of an element in the database (in bits). 
    
    Equation \ref{eq:chunk_estimator} shows how the number of chunks are calculated. 
    \begin{equation}
        number of chunks = \left \lceil \frac{element\_size\_bit}{\lfloor log_2(p\_mod) \rfloor} \right \rceil
        \label{eq:chunk_estimator}
    \end{equation}
    \item base\_p\_decompose(n,p, chunks): This function will do a base-p decomposition of a big integer $n$ into $chunks$ amount of chunks. Euclidian division of the integer $n$ by the plaintext modulus $p$ is used. The division will be done $chunks$ amount of times, and every chunk will keep the remainder of the division. This will create a vector of size $chunks$, containing numbers smaller than $p$.
    \item recompose\_base\_p\_to\_str(digits, p): This function will recompose the chunks back into one large integer. It will take the vector of chunks and the plaintext modulus $p$. The recomposition is done by multiplying every chunk with $p^i$, with $i$ the index of the chunk in the vector. The results are summed together to create one large integer, which is then converted to a string and returned.
    \begin{equation}
        n = \sum_{i=0}^{chunks-1} digits[i] \cdot p^i
    \end{equation}
    \item \verb|get_rand_matrix(nr_elements, element_size_bits, nr_slots, p)|: To create the database, this function is used. It will create a 3D-matrix with size $r \cdot c \cdot d3$, with $r$ the number of slots in a ciphertext, $c$ the number of elements divided by the number of slots, and $d3$ the amount of chunks needed to split one large element. Every element in the database is a large integer with size equal to $element\_size\_bits$. Every large integer is split into $d3$ chunks via base-p decomposition. This function will return the 3D-matrix.
    % To increase the performance, one can already shift the elements of the next chunks. This will allow to avoid the rotate-operation when the server is computing, to fit multiple chunks in one ciphertext.  
\end{itemize}

