\chapter{Theoretical background}
\label{cha:2}

\section{Homomorphic encryption}
Homomorphic encryption (HE) allows computations to be performed on encrypted data without needing to decrypt. As discussed above, there are multiple types of HE: PHE which only supports multiplication or addition and LHE/FHE which supports both addition and multiplication.

Whilst performing a large number of (complex) operations, noise added to the HE ciphertext will grow and overwrite data. To avoid this, two methods are used: using big integers as ciphertext modulus and bootstrapping. By using big integers as ciphertext modulus, enough space is provided for the noise to grow for the full computation - the so-called leveled schemes (LHE)\footnote{BFV and CKKS are often implemented without bootstrapping, as a leveled scheme, but are bootstrappable.}.
To have more computation depth possible (FHE), bootstrapping operations are performed to reduce the amount of noise in between chains of computations. One should note that bootstrapping is computationally and memory-intensive.  

FHE schemes can be divided into multiple generations, depending on the type of bootstrapping techniques \cite{robin_bootstraping_BGV_BFV}.
First generation schemes include schemes like the Gen09 bootstrapping technique, described in 2009, which is illustrated in Figure \ref{fig:boot09} \cite{ilaria_chillotti_zama_tfhe_2022}. FHE-encrypted data are FHE-encrypted a second time, with a lower level of noise compared to the initial encryption. Subsequently a bootstrapping key is sent to the computing node, which is the secret key of the initial encryption, encrypted with the public key of the second encryption. Decryption with this bootstrapping key removes the first encryption layer, and one ends up with data solely encrypted via the second FHE-scheme, with a lower level of noise. This type of scheme is no longer used in practical implementations.

\begin{figure}
    \centering
    \includegraphics[width=0.65\textwidth]{fig/Bootstrapping.png} 
    \captionof{figure}{Gen09 bootstrapping \cite{ilaria_chillotti_zama_tfhe_2022}}
    \label{fig:boot09}
\end{figure}

Second generation schemes are defined by having a slow and complex bootstrapping. However, bootstrapping cost is compensated by the use of SIMD (Single Instruction Multiple Data) operations, which will distribute this cost over many slot, so many parallel computations. Examples are BGV, BFV and CKKS. 
Third generation schemes are characterized by a very simple and fast bootstrapping procedure. These exhibit lower circuit complexity, faster execution times, and less noise growth when compared to the second generation schemes. On the other hand, they will not offer SIMD slots for parallel processing. Examples include torus FHE (TFHE). 

Next to these generations, some leveled homomorphic encryption schemes are known without any efficient bootstrapping technique. The CLPX scheme from Chen et al. \cite{Chen_CLPX_paper} is an example, where the parameters of the scheme are set as such level to allow deep circuit evaluation before noise corrupts the result.

\section{Cyclotomic rings and (R)LWE}

\subsection{Cyclotomic rings}
BFV (Brakerski-Fan-Vercauteren) is built on the RLWE problem (ring learning with errors), which is a hardness problem used in cryptography. We define the $m$-th cyclotomic polynomial as follows: 
\[
\Phi_m(x) = \prod_{j \in \mathbb{Z}_m^\times} \bigl(x - \omega_m^j\bigr)
\]

\begin{itemize}
    \item $w_m \in \mathbb{C}$ is a primitive $m$-th root of unity, where $m\ge 1$
    \item $\mathbb{Z}_m^\times$ is the unit group of integer modulo $m$.
\end{itemize}

The degree of the cyclotomic polynomial is equal to $\varphi(m)$, the result of Euler's totient function of $m$. Although the cyclotomic polynomial has complex roots, it has been proven that the coefficients are integer numbers and the polynomials are monic (leading coefficient is 1) and irreducible\cite{AlKateeb2016Cyclotomic}. The RLWE problem is then defined over the ring $\mathbb{R} = \mathbb{Z}[x]/(\Phi_m(x))$. This ring is a subring of the cyclotomic number field $\mathbb{Q}[x]/(\Phi_m(x))$.

\subsection{LWE}
 The ciphertext is constituted of two parts: uniform random numbers $a_{i}$ and $b$, where $b$ is the sum of the multiplication of the uniform random numbers $a_{i}$ with the secret key $s_{i}$, some Gaussian distributed noise $e$ and the message $m$, normalized by a delta coefficient. The corresponding ciphertext can be represented on a ring, all the possible values of $m$ are put on a ring, at a spacing $\Delta$ from each other. To decrypt, the decryption formula \eqref{eq:decrypt_LWE} is used, which is equivalent to rounding the value on the ring (which corresponds to $\Delta$ times the message plus the error) to the closest possible value for m. If the error becomes too large, the value will round to the wrong message value, so returning a faulty message. 

% One-line RLWE ciphertext definition
\begin{equation}
    \text{Encryption:} \quad ct = (a_0, \dots, a_{n-1}, b) \quad \text{where} \quad 
b = \sum_{i=0}^{n-1} a_i s_i + e + \Delta m
\label{eq:encrypt_LWE}
\end{equation}
\begin{equation}
\text{Decryption:} \quad
m \approx \frac{b - \mathbf{a} \cdot \mathbf{s}}{\Delta}
\label{eq:decrypt_LWE}
\end{equation}

\begin{itemize}[noitemsep, label={}]
  \item $a_i \in \mathbb{Z}_q$ are chosen uniformly at random
  \item $s_i \in \mathbb{Z}_q$ are the secret key coefficients
  \item $e \in \mathbb{Z}_q$ is a small error term (typically Gaussian)
  \item $m$ is the message encoded in the ring
  \item $\Delta$ is the message scaling factor
  \item $b \in \mathbb{Z}_q$ is the second component of the ciphertext
\end{itemize}
This scheme already allows to do some operations on the ciphertext: we can add two ciphertexts and perform multiplications of the ciphertext with non-encrypted integers\footnote{An operation on ciphertexts will, in FHE, correspond to an operation on plaintexts.}.


\subsection{RLWE} Ring LWE is similar to LWE but the message, secret key, random values and error are all polynomials in the cyclotomic ring $\mathcal{R}_q=\mathbb{Z}_q[x]/(f(x))$ rather than vectors over integers. Ciphertexts are constructed using polynomial arithmetic modulo a cyclotomic polynomial.  
When encrypting, we will normalize the message and add a Gaussian error, like in LWE. For every coefficient of the polynomial, the value of $\Delta$ $s$ plus the error will again be represented on a ring. Rounding will give the polynomial coefficients of the message $m$. 
The RLWE scheme allows to perform additions between ciphertexts and multiplication with non-encrypted constant polynomial functions.

The RLWE distribution consists of pairs $(a, b) \in \mathcal{R}_q \times \mathcal{R}_q$, where $a$ is chosen uniformly at random from $\mathcal{R}_q$ and $b = a \cdot s + e$, with $e$ and $s$ sampled at random over $\mathcal{R}_q$.

There exist two variants of the RLWE-problem, search RLWE and decision RLWE.

\textit{\textbf{Search RLWE:} Let $\mathcal{R}$ be an RLWE instance. The search RLWE problem, denoted by SRLWE($\mathcal{R}$), is to discover s given access to arbitrarily many independent samples $(a, b)$.}

\textit{\textbf{Decision RLWE:} Let $\mathcal{R}$ be an RLWE instance. The decision RLWE problem, denoted
by DRLWE($\mathcal{R}$), is to distinguish between the same number of independent samples in two distributions
on $\mathcal{R}_q \times \mathcal{R}_q$. The first is the RLWE distribution of $\mathcal{R}$, and the second consists of uniformly random and
independent samples from $\mathcal{R}_q \times \mathcal{R}_q$.}

Both variants are supposed to be hard\cite{Balbas2021}. Note that the search RLWE problem can be reduced to the decision RLWE problem \cite{Hao2015RLWEreduction}.

\section{BFV and CLPX}
In BFV by Kim et al.\cite{BFVrounding_Kim, Brakerski2012, Fan2012}, a subquotientring $\mathcal{R}_t$ of $\mathcal{R}$ is created by taking modulo t the ring $\mathcal{R}$. In the case of BFV, we fix this $t$ to a prime integer $p$. The ciphertext also has a modulus q and the message is scaled by a factor $\delta = q/t$.
The plaintext space corresponds to $R_t = \mathbb{Z}[x]/(\Phi_m(x), p)$.
Encryption is then done via following formula:
\begin{align}
\text{Ciphertext:} \quad 
\mathbf{ct} &= \big( \big[\lfloor \Delta \cdot m \rceil + \mathbf{a} \cdot \mathbf{s} + e \big]_q , -\mathbf{a} \big) \\[2mm]
\text{Decryption:} \quad 
m &= \Big\lfloor \frac{c_0 + c_1 \cdot \mathbf{s}}{\Delta} \Big\rceil
\end{align}

The scheme can be implemented as a leveled scheme or can be bootstrapped to a fully homomorphic encryption scheme. In BFV, one can perform addition, multiplication and automorphism over the plaintext space.

In CLPX, the idea is to use a plaintext ring modulo $t$, with $t=x-b$ instead of an integer $p$, as in BFV. The plaintext space is now defined as
\begin{equation}
    \mathcal{R}_t = \mathbb{Z}[x]/(\Phi_m(x), x - b) = \mathbb{Z}[x]/(x - b, p) \cong \mathbb{Z}_p \text{while} p=\Phi_m(b)
\end{equation}

In this CLPX-scheme, $m$ is a $k$-th power of 2. When encrypting, a hat encoding is performed first on the message m, by taking the modulus quotient ring of R modulo t. We get $\hat{m}$ which only has small coefficients. Encryption is done as follows:
\begin{equation}
\mathbf{c} = \Big( \big[ \Delta \cdot \hat{m} + \mathbf{a} \cdot \mathbf{s} + e \big]_q , -\mathbf{a} \Big)
\end{equation}

Decryption is performed using the secret key $\mathbf{s}$:
\begin{equation}
\hat{m} = \Big\lfloor \frac{t}{q} \cdot \big( c_0 + c_1 \cdot \mathbf{s} \big) \Big\rceil
\end{equation}
In CLPX, addition and multiplication can be performed homomorphically \cite{Chen_CLPX_paper}.

CLPX can encrypt a single huge integer modulo $\Phi_m(b)$ and has much lower noise growth when compared to BFV - the growth is sublinear in the desired precision, it depends on $b$ instead of $\Phi_m(b)$ \cite{Geelen2024FHECyclotomic}. This makes CLPX suitable for high-precision arithmetic HE operations. 
However, in CLPX Only a single element is encrypted, so no SIMD operations can be performed. Also, since the size of $p$ is exponential in $m$, bootstrapping is made challenging. However, a recent work by Kim demonstrated  \cite{Jeahyunk2025}.

\section{GBFV}
CLPX has much lower noise growth when compared to BFV, but does not support SIMD operations and is not known to be efficiently bootstrappable for cryptographically secure parameters. Geelen and Vercauteren propose the GBFV scheme which combines the SIMD and bootstrapping capabilities of BFV with the lower noise growth of CLPX, by tuning the parameters $m$ and $t(x)$. Combing both properties would either yield a scheme capable of evaluating deeper circuits or would yield a scheme capable of working with smaller ring dimensions. 

GBFV operates over the cyclotomic ring $\mathcal{R}=\mathbb{Z}[x]/\phi_m(x)$. The plaintext space is defined modulo an arbitrary non-zero principal ideal generated by a polynomial $t=t(x)$. This ring is $R_t=R/tR$. 
A plaintext $m \in \mathcal{R_t}$ is encrypted into a ciphertext $ct \in \mathcal{R}_q^2$ with RLWE:  
\begin{equation}
    ct = \left( \big[ \lfloor \Delta \cdot m \rceil + a \cdot s + e \big]_q, \; -a \right)
    \footnote{$\lfloor x \rceil$ is rounding to the nearest integer}
\end{equation}


The ciphertext space will be a ring $\mathcal{R}_q^2$ with $q\ge2$. The scaling factor $\Delta$ is defined by $q/t$, with $q$ the ciphertext modulus. This scaling factor is not rounded to $\mathcal{R}$, resulting in a conceptually simpler scheme definition when compared to BFV and CLPX.

For correct decryption, the canonical infinity norm of the plaintext modulus must be much smaller than the ciphertext modulus. This ensures that the decryption correctly recovers plaintexts without modular wrap-around or rounding errors, all contributions from $t(x)$ (i.e. $t(x) \cdot m(x)$) and the noise must be much smaller than q.

\subsection{Scheme functions}
The GBFV scheme has several functions which it can perform:
\begin{itemize}
    \item Secret key generation: Samples a secret key $s$ from a key distributon $\chi_{key}$, $s \in \mathcal{R}$, returns s.
    \item Relinearization key: after multiplication of ciphertexts, one gets a higher order  polynomial in $s$, which can not be decrypted since the scheme only knows $s$ and not $s$ to a higher power. The relinearization key approximates the ciphertext back to a linear equation in s. Returns the relinearisation key.
    \item Decryption: A ciphertext is decrypted using $m = \left\lfloor \frac{c_0 + c_1 \cdot s}{\Delta} \right\rceil$. Returns $m$.
\end{itemize}

GBFV supports standard homomorphic operations on ciphertexts, using following functions:
\begin{itemize}
    \item Ciphertext-ciphertext addition: ciphertext addition is done component-wise modulo $q$ and returns $ct_{add}$. 
    \item Plaintext-ciphertext addition: the plaintext is encrypted as follows: \[ct' = \left( \big[ \lfloor \Delta \cdot m \rceil \big]_q, \; 0 \right)\]
    After this stage, add the original ciphertext with $ct'$ (ciphertext-ciphertext addition).
    \item Key switching: reduces the result of the ciphertext-ciphertext multiplication back to two components.
    \item Ciphertext-ciphertext multiplication: two ciphertexts $ct=(c_0,c_1)$ and $ct'=(c_0',c_1')$ are multiplied as follows: 
\begin{align}
\mathbf{c}'' &= \Big( 
  \big[ \big\lfloor \frac{c_0 \cdot c'_0}{\Delta} \big\rceil \big]_q,\;
  \big[ \big\lfloor \frac{c_0 \cdot c'_1 + c_1 \cdot c'_0}{\Delta} \big\rceil \big]_q
\Big), \\[2mm]
c''_2 &= \Big[ \big\lfloor \frac{c_1 \cdot c'_1}{\Delta} \big\rceil \Big]_q
\end{align}
    Since the $c_2''$ contains a second-order term in s, a relinearization is performed using the relinearization key, creating $ct'''$. This ciphertext is then added to $ct''$. 
    \item Ciphertext-plaintext multiplication: takes the ciphertext and multiplies both parts with the flattened message $m$. Flattening involves reducing the coefficients from, ensuring the coefficients are reduced modulo $t$ but expressed in $\mathcal{R}$. Following formula is used: 
\[\text{Flatten} : \mathcal{R}_t \rightarrow \mathcal{R}: \quad 
m \mapsto t \cdot \big[ \frac{m}{t} \big]_1
\]

    \item Automorphism. Applying an automorphism to the ciphertext polynomials, this permutes slots in packed plaintexts after decryption. Then, the plaintext moduli are corrected if they changed under the automorphism. A key switching is performed to bring back the secret key to s. Finally, the adjusted ciphertexts are combined to form the final output. 
    
\end{itemize}

\section{SIMD}
Smart and Vercauteren \cite{Smart2012FullyHS} noticed that it was possible to encode multiple elements in one plaintext/ciphertext, using the Chinese Remainder Theorem. This splitting in slots can allow SIMD operation - performing a single operation on multiple data. 

SIMD allows to perform following operations such as:
\begin{itemize}
    \item Addition: component-wise addition of slots.
    \item Multiplication: component-wise multiplication of slots.
    \item Slot rotations: shifting slots in the plaintext/ciphertext. The shifting is performed different in BFV and GBFV. In BFV, the slots are usually structured in a 2D-hypercube, so rotations can be performed along the two dimensions. In GBFV, the slots are structured as a 1D-array, so rotation is a slot-shift along the axis. 
\end{itemize}

BFV can support packing in slots and thus SIMD operations. However, doing this puts a restriction on the use of BFV. If $p = \Phi_m(b)$ is the modulus of the plaintext, the upper bound of the output noise will grow proportional to the product of this factor and the sum of the upper bounds on the input noise. When one wants to have a high precision arithmetic, one chooses a high $p$, which will result in more output noise. This makes BFV SIMD-schemes impractical when performing precise arithmetic calculations, often needed in HE-applications. For instance, privacy-preserving machine learning \cite{Giland_ML_big_P} uses moduli up to 80 bits. Also, a higher value of $p$ enables a higher packing density \cite{Geelen2024FHECyclotomic}. The packing density, which is equal to the number of slots divided by the ring dimension, is equal to 1/$d$. $d$ is the multiplicative order of $p$ modulo the cyclotomix index $m$. To achieve full packing, $p$ needs to be larger than $m$. When using power-of-two cyclotomics, the number of slots will be upper bounded by ($p$+1)/2 \cite{Geelen2024SlotsToCoefficients}. To conclude, while a large value of $p$ allows for greater packing density and more precise arithmetic operations, it simultaneously exacerbates noise growth.

GBFV works modulo a plaintext modulus polynomial $t(x)$, hereby defining a plaintext ring $\mathcal{R}_t = \mathcal{R}/(t(x))$. To enable SIMD computation we want this plaintext space to be isomorphic to a product of fields. By the Chinese Remainder Theorema, this decomposition in fields allows a plaintext to be represented as a number of slots, so SIMD operations are also possible when using GBFV. Homomorphic operations will then be performed component-wise on these slots. This enables parallel computation and rotation of slots can be performed via automorphisms. 

\section{Private information retrieval}
When retrieving information from a remote server, the database holder will know which elements are queried if no security measures are implemented. To protect the user, one wants to hide which elements are queried from the server. Private information retrieval or PIR is often considered to achieve this goal.

The goal of PIR is to ensure the server does not learn anything about the index from the user query. 
This will enhance the privacy of the user, since no information will be leaked to the (remote) server(s), potentially causing serious privacy issues. PIR finds application in multiple scenarios where sensitive data are used. For example, a doctor querying a database with a patient's medical data will get back the requested medical information, without the server learning which patient or which patient record was requested. PIR also finds application in technology. Apple uses PIR to provide caller ID information of an incoming phone call, without them learning who is calling who \cite{apple_PIR}. 

 
PIR protocols can be categorized in two groups: single-server PIR and multi-server PIR. 
The single-server PIR is the most straightforward setting: one server holds the full dataset, and the client queries the server to get the data of interest.
In multi-server PIR, there are multiple servers holding a copy of the full dataset, and the client queries multiple servers to obtain the data of interest. The core idea when using multi-server PIR is that, although the dataset is replicated on multiple servers, the query is split into parts. In this way, none of the servers learn which bit is requested but the requested bit can be recovered from the results of the different servers. 

A multi-server PIR scheme is demonstrated in Figure \ref{fig:multiserver_pir}. Let D be the database with 4 bits $[b_1, b_2, b_3, b_4]$, and the client wants to retrieve bit \( b_3 \) privately. There are two non-colluding servers holding a copy of the database. The client will sample a random binary vector $q_1$ and will make $q_2$ by XORing $q_1$ withe a zero vector with a one at the position of the wanted element $e_3$. Subsequently both queries are sent to both servers. The servers compute $a_1$ and $a_2$, and return them to the client. Afther XORing both responses the client can retrieve $b_3$. Each server sees a random-looking query, so neither learns which index was requested as long as they do not collude.

\input{fig/multi_server_PIR_example}

Security holds as long as the servers do not collude. This assumption is difficult to achieve, because the database is usally under one authority and distributing the database on multiple servers with different authorities is mostly not feasible in practice. Therefore, single-server PIR schemes are often preferred since they rely on cryptographic hardness assumptions, but at the cost of incurring a performance overhead.  
In this thesis, we will further focus on single-server PIR. 

A scheme is information-theoretically secure when the queries asked by the user give no information whatsoever about the requested bit to the server. Multi-server PIR schemes can achieve information-theoretic security, such as the PIR-protocol proposed by Ghoshal et al. \cite{Ghoshal2024}. Single-server PIR schemes can not achieve information-theoretic security. One exception, when the single server sends the full database to the client. The client can then query the database and the server will not learn anything about the requested bit. However, this trivial scheme has a communication cost of $\mathcal{O}(n)$, with $n$ the size of the database. Single-server PIR schemes with smaller communication cost are only computationally secure; computationally secure schemes only guarantee that the server can not compute the requested bit in a reasonable amount of time, given the queries. 
Kushilevitz and Ostrovsky made use of the number-theoretic assumption to deduce a single-server computationally secure PIR with subpolynomial communication cost \cite{kushilevitz1997}. The scheme has a communication complexity of $\mathcal{O}(n^\epsilon)$ for any $\epsilon > 0$. This scheme however requires $n$ big integer multiplications.
Cachin et al. proposed a two-round computationally secure PIR using the $\phi$-hiding assumption where communication complexity is polylogarithmic in $n$. This scheme requires $n$ modular exponentiations, with large moduli, which makes multiplication slower then in Kuhilevitz's scheme \cite{Christien1999}.
Chang subsequently proposed a scheme with logarithmic communication complexity, using Paillier's cryptosystem \cite{paillier1999,Chang2004}.
In 2007, Sion and Carbunar pointed out that these single-server PIR protocols are mostly orders of magnitude slower than the trivial transfer of the entire database to the client \cite{sion2007}. However, later work by Aguilar-Melchor et al. showed that this argument is incorrect: single-server PIR can be faster than downloading the entire database, when using lattice-based cryptographic methods. These methods have smaller per-bit computation cost when used in a batched fashion \cite{Aguilar-Melchor2014}. 

More recent PIR protocols make use of fully homomorphic encryption. FHE typically incurs significant communication overhead due to the ciphertext expansion factor. However, keeping the query size as low as possible while maintaining computation cost reasonable is the objective in these protocols. Arranging the database as a hypercube will increase the computation efficiency, as used in Respire \cite{Respire2024}. Furthermore, transciphering can be used to further lower the query size. In transciphering, the client will use a symmetric encryption scheme to encrypt the query, which is then homomorphically evaluated on the server side. The server will homomorphically decrypt the query and evaluate it on the database, returning the encrypted result to the client. The client will then decrypt the result symmetrically. This method reduces communication cost since FHE ciphertexts are only used for the query and result, while symmetric encryption is used for the database. 
Kang proposed a novel transciphering method to further reduce the communication cost when compared to (T-)Respire \cite{TRespier2024,TRespier2025}. In this scheme, the client transmits only one part of the LWE ciphertext. The full LWE ciphertext is reconstructed using a pseudo-random generator seed shared between the client and server. By sending only a single LWE component and a short seed, Pirouette succesfully achieves query compression while keeping computational cost associated with transciphering reasonable \cite{Pirouette2025}.

\section{PIRANA}
PIRANA is a single-server protocol developed at Zhejiang University \cite{PIRANA2023}. 
The protocol is based on constant-weight codes, which is a way to encode the queries. In constant-weight codes, all codewords have a length $m$ and have the same Hamming weight, meaning they have the same number of ones. In later steps, it will be clear how the database is structured and how information is retrieved. There should at least be the same amount of codewords as there are columns in the database. To estimate the length of the codeword in bits, we need to know the number of columns and the Hamming weight $k$. The number of codewords is equal to the binomial coefficient \( \binom{m}{k} \). To estimate the code length $m$, knowing the Hamming weight $k$ and the number of columns $n$, we can then use following formula: 
\begin{equation}
    m \in O\!\left(\sqrt[k]{k! \, n}  + k \right)
\end{equation}
According to the Mahdavi-Kerschbaum mapping method, every index $i$ of a column is mapped to the $i$-th codeword.

PIRANA can be used in single-query and multi-query set-up. In the following part, single-query PIRANA will be discussed for small and large payloads, as well as a comparison of PIRANA with constant-weight PIR (cwPIR).

\subsection{Single-query PIRANA for small payloads}
In single-query PIRANA for small payloads, the client wants to retrieve a single element from the database. Small payloads means the elements in the database are smaller than the plaintext modulus $p$. So multiple elements can be packed in one ciphertext. The database of $n$ elements is structured as a 2D-matrix with $r$ rows and $t$ columns, where $n = r \cdot t$ and $r$ is the number of slots in a ciphertext. Every column is represented by one codeword of length $m$ and Hamming weight $k$. To determine $m$ and $k$, one wants to find the smallest $m$ such that \( \binom{m}{k} \ge t \). 
Figure \ref{fig:single_query_PIRANA} shows how to retrieve an element in position $(i,j)$ using single-query PIRANA for small payloads. The client constructs a query made out of $m$ ciphertexts $\widetilde{q}_{1 \dots m}$, with $r$ ciphertext slots, thereby constructing a matrix of size $m \times r$. 
This is a all-zero matrix, except for the $i$-th row, which contains the codeword corresponding to column $j$. This query is then sent to the server. 
The sever will receive this query and, for every column, will take the corresponding codeword. For every bit equal in the codeword, the server will take the corresponding column from the query and perform $k-1$ homomorpic multiplications. The server will do this for all columns, thus $(k-1)\cdot n$ ciphertext-ciphertext multiplications. Hereby creating a selection matrix of $t$ ciphertexts $\widetilde{w}_{1 \dots t}$, where every ciphertext contains $r$ slots. Thus, the selection matrix has a size $r \times t$. All values in these matrix are zero, except for the position $(i,j)$, which contains the one. The server will then perform a ciphertext-plaintext multiplication between the columns of the selection matrix $\widetilde{w}$ and the columns of the database $d_{1 \dots t}$. This can be done because the dimensions of both matrices match.
This will return $t$ columns $\widetilde{u}_{1 \dots t}$. Every ciphertext contains all zeros, except the $j$-th ciphertext, which will contain the payload at slot $i$. To reduce the amount of ciphertexts sent back to the client, the server will sum up all columns, returning a ciphertext $\widetilde{v}$ with $r$ slots, where all slots are zero, except for slot $i$, which contains the requested element. This ciphertext is sent back to the client, who will decrypt and get the requested element.

% Figgur van Single-Query Pirana
% \input{fig/PIRANA_sigle_server.tex}

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{fig/Single_query_PIRANA_smal_paylaod.png} 
    \captionof{figure}{Single-query PIRANA for small payloads \cite{PIRANA2023}}
    \label{fig:single_query_PIRANA}
\end{figure}

This protocol has some flaws. First of all, if $n$s is large, the amount of ciphertext-ciphertext multiplications becomes huge. Secondly, the communication cost to retrieve one element is high, since the client needs to send $m$ ciphertexts to the server, and the server will return one ciphertext with $r$ slots. Lastly, when choosing a large $k$, the amount of ciphertext-ciphertext multiplications increase and $m$ increases too, which will increase the communication cost.

\subsection{Single-query PIRANA for large payloads}
PIRANA can also be used for large payloads, i.e. elements that are bigger than the plaintext modulus $p$. Every element is split into multiple chunks, each chunk $ch$ smaller than $p$. The database is now a 3D-matrix of size $r \times t \times \ell $, where $\ell$ equals the number chunks per element. The selection matrix is created in the same way as for small payloads, resulting in a matrix of size $r \times t$. This selection matrix is now multiplied column-wise with every layer of the database. 
The result of this multiplication gives a 3D-matrix of size $r \times t \times \ell$. In the same way as for small payloads, every column $\widetilde{u}_{\cdot,n}$ of a layer $n$ is added to create $\widetilde{v}_n$. This is done for every layer, thereby giving $\widetilde{v}_{1 \dots \ell}$. To reduce the amount of $\widetilde{v}$ ciphertexts sent back to the client, rotate and sum is performed as displayed in Figure \ref{fig:rotate_and_sum_PIRANA}. Every column $\widetilde{v}$ is a ciphertext with all zeros, except at position $i$. These positions contain one chunk $ch_n$ of the requested element. An accumulator $acc$ is initialized with the first column/ciphertext, rotated by one position. Subsequently, the second column is added to this accumulator. The accumulator is then rotated by one position again, and the third column is added to the accumulator. This is repeated until all columns are added. If there are more chunks than slots in a ciphertext, $\ell/r$ ciphertexts are needed to retrieve the remaining chunks. By performing the rotate-and-sum operation, the response query goes from $\ell$ to $\ell/r$ ciphertexts. The final ciphertexts are sent back to the client, which will decrypt and can reconstruct the requested element, by combining the chunks. 

%rotate-and-sum figuur
\begin{figure}
    \centering
    \input{fig/Rotate_and_sum_PIRANA.tex} 
    \captionof{figure}{Rotate-and-sum operation}
    \label{fig:rotate_and_sum_PIRANA}   
\end{figure}

For small database size $n$, one could pre-compute the rotations in the set-up time of the database. This will reduce the computation time when performing a query to the database. 

\subsection{PIRANA performance comparison}
Liu et al. compared the performance of PIRANA with constant-weight PIR in table \ref{tab:pir_comparison}. PIRANA was implemented in C++ based on Microsoft SEAL HE library \footnote{https://github.com/microsoft/SEAL}, and the BFV scheme was used with $N \in \{4096,8192\}$. Tests are performed on an Intel Xeon Cooper Lake with a base frequency of 3.4 GHz and turbo frequency of 3.8 GHz. The server was running on Ubuntu 20.04. This set-up is done similar to the set-up of cwPIR \cite{Mahdavi2022}.
PIRANA outperforms cwPIR in terms of selection vector generation time. As expected: in PIRANA $c \cdot (k-1)$ ciphertext-ciphertext multiplications are needed, while in cwPIR $n \cdot (k-1)$ multiplications are needed. When the database size $n$ increases, the difference in performance becomes larger. Inner product calculation is also faster in PIRANA when compared to cwPIR. In cwPIR, every ciphertext needs to be transformed using NTT (number theoretic transform) before multiplying with the database. In PIRANA, there are only $m$ ciphertexts to transform, which is $r$ times smaller than $n$. The query size of PIRANA is up to 2.5 times larger when compared to cwPIR, and the response size is equivalent. Thus, commmunication cost is higher in PIRANA. But, one can query $\left\lfloor \frac{N}{1.5} \right\rfloor$ elements for the same communication cost in PIRANA (multi-query).

%Pirana vs cwPIR table
\begin{table}[t]
    \centering
    \caption{Performance comparison of CwPIR and PIRANA \cite{PIRANA2023}}
    \label{tab:pir_comparison}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{l l ccccccccc}
        \toprule
        & \# elements $n$ 
        & $2^8$ & $2^9$ & $2^{10}$ & $2^{11}$ & $2^{12}$ & $2^{13}$ & $2^{14}$ & $2^{15}$ & $2^{16}$ \\
        & DB Size (MB) & 5.2 & 10 & 21 & 42 & 84 & 170 & 340 & 670 & 1300 \\
        \midrule
        \multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}CwPIR \cite{Mahdavi2022}\end{tabular}}
        & Selection Vec. (s) & 3.9 & 7.8 & 15.5 & 31.0 & 61.7 & 123.1 & 246.2 & 492.7 & 983.3 \\
        & Inner Product (s) & 0.2 & 0.4 & 0.8 & 1.6 & 3.3 & 6.5 & 13.1 & 26.2 & 52.3 \\
        & Total server (s) & 4.1 & 8.2 & 16.3 & 32.6 & 65.0 & 129.7 & 259.4 & 518.9 & 1035.6 \\
        \midrule
        \multirow{4}{*}{\begin{tabular}[c]{@{}l@{}}PIRANA\\(single-query)\end{tabular}}
        & Selection Vec. (s) & 0.001 & 0.001 & 0.001 & 0.001 & 0.001 & 0.001 & 0.027 & 0.05 & 0.1 \\
        & Inner Product (s) & 0.22 & 0.24 & 0.28 & 0.36 & 0.52 & 0.86 & 1.57 & 2.86 & 5.39 \\
        & Total server (s) & 0.22 & 0.24 & 0.28 & 0.36 & 0.52 & 0.86 & 1.6 & 2.9 & 5.49 \\
        & Speedup & 18.6$\times$ & 34.2$\times$ & 58.2$\times$ & 90.6$\times$ & 125$\times$ & 151$\times$ & 162.1$\times$ & 178.9$\times$ & 188.6$\times$ \\
        \bottomrule
    \end{tabular}
    }
\end{table}

PIRANA was also compared to some state-of-the-art PIR schemes by Liu et al. \cite{PIRANA2023}. To answer a single query, PIRANA is mostly slower than other PIR schemes. However, PIRANA becomes more competitive when the number of queries increases. 

\section{Fheanor}
In this thesis, we will implement GBFV in the Fheanor library\footnote{https://github.com/FeanorTheElf/fheanor}. Feanor is a Rust library containing building blocks for homomorphic encryption, implementing several FHE schemes, including BFV and CLPX\footnote{CLPX is not implemented in any other major library \cite{feanor_paper}}. Fheanor is build on feanor-math\footnote{https://github.com/FeanorTheElf/feanor-math}, a Rust library for number theory and algebra. Both libraries are open-source and can be found on GitHub.

The library supports implementations over both power-of-two and genaral cyclotomics \cite{feanor_paper}. This is interesting for FHE implementations, in particular because the use of non-power-of-two cyclotomics can allow greater SIMD capabilities by having a larger number of slots with small plaintext moduli. Fheanor also explicitly models arithmetic circuits, providing tools for their computation. The Fheanor library is close in performance to the HElib and SEAL libraries, which are state-of-the-art. 

Spiessens created a wrapper called easy-GBFV, which will use the Fheanor library to create a GBFV-scheme. This wrapper offers some easy-to-use functions. Some functions that will be used in this GBFV implementation are:

\begin{itemize}[noitemsep]
    \item \verb|get_gbfv_(16/32/64)bit()|: creates a GBFV scheme with plaintext modulo 16, 32, or 64 bits.
    \item \verb|pack()|: to get an amount of slots in a ciphertext.
    \item \verb|slot_ring()|: hands the canonical slot ring instance that the hypercube uses for plaintext packing.
    \item \verb|gen_sk()|: generates a secret key for the GBFV scheme.
    \item \verb|gen_pk(&SecretKey)|: generates a public key for the GBFV scheme.
    \item \verb|enc_slots()|: will take the output of slot\_ring() and encrypt it.
    \item \verb|dec_slots()|: will decrypt a ciphertext and return the slots.
    \item \verb|clone_ct()|: clones an element of the ciphertext.
    \item \verb|hom_mul()|: performs homomorphic multiplication between two ciphertexts.
    \item \verb|hom_rotate()|: will rotate the slots in the ciphertext.
    \item \verb|hom_matmul()|: performs homomorphic matrix multiplication between a ciphertext and a plaintext matrix.
    \item \verb|hom_add()|: performs homomorphic addition between two ciphertexts.
\end{itemize}


    % add the parameters